大家到目前为止都接触过哪些缓存机制 ？
1.堆内存当中的字符串常量池
 > “abc”先在字符串常量池中查找，直接拿来用，如果没有则新建，然后再放入到字符串常量池中
2. 堆内存当中的整数型常量池
 > [-128-127] 一共256个Integer 类型的引用，放再整型常量池大当中，没有超出整个这个范围的话，直接从常量池当中取出。
3. 数据库连接池 (Connection Cache)
 > 这里所说的连接池中的连接是Java语言连接数据库的连接对象，java.sql.Connection 对象。
 > JVM是一个进程，MySQL数据库是一个进程，进程和进程之间建立连接，打开通道是很费劲的，
   是很耗费资源的，怎么办？可以提前先创建好N个Connection 连接对象，将连接对象放到一个集合当中，
   我们把这个放有 Connection 对象的集合称之为连接池，每一次用户连接的时候不需要再新建连接对象，
   省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。
   < 最小连接池 ，最大连接池.
   < 连接池可以提高用户的访问效率，当然也可以保证数据库的安全性。
4.线程池
 > Tomcat 服务器本身就是支持多线程的
 > Tomcat 服务器是在用户发送一次请求，就新建一个Thread多线程对象吗》
   > 当然不是，实践上是在Tomcat 服务器启动的时候，会先创建N多个线程Thread对象，
   然后将线程对象放到集合当中，称为线程池，用户发送请求过来之后，需要有一个对应的线程来
   处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。
 > 所有的Web服务器，或者应用服务器，都是支持多线程的，都有线程池机制。

5. Redis
  > NoSQL数据库，非关系型数据库，缓存数据库
  > 向ServletContext应用域中存储数据，也等于将数据存放到缓存Cache当中了。

_________________________________________________________
HTTP协议:
1.HTTP协议，是W3C制定的一种超文本传输协议。(通信协议：发送信息的模板提前被制定好。)
什么是超文本？
超文本就是：不是普通文本，比如流媒体: 图片，视频，声音等。
HTTP协议支持：不但可以传送普通字符串，同样支持传递声音，视频，图片等流媒体信息
这种协议游走在B和S之间，B(浏览器)向S(Servlet 服务器)发送数据要遵循HTTP协议，
S向 B 发送数据同样需要遵循HTTP协议，这样B和S才能解耦合。
这里的解耦合是：B不依赖 S ,S 也不依赖B
HTTP协议包括：
1.请求协议(浏览器向web服务器发送请求 request)
  > 浏览器向web服务器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体的格式。
2.响应协议：(web 服务器响应浏览器的请求 ：response)
  > Web服务器向浏览器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。
HTTP协议就是提前制定好的一种信息模板：
1. 不管你是哪个品牌的浏览器，都是这么发。
2. 不管你是哪个品牌的服务器，都是这么发。
3. FF浏览器，可以向Tomcat 发送请求，也可以向Jetty服务器发送请求，浏览器不依赖具体的服务器品牌。
4. Web浏览器也不依赖具体的浏览器品牌，可以是FF浏览器，也可以是Chrome浏览器，可以是IE，都行.
________________________________________________________
HTTP的请求协议：
  1. 请求行
  请求行： 包括三部分：
    > 请求方式(7种)
     get(常用的)
     post (常用的)
     URL
     HTTP 协议的版本号
    > URI  和 URL 的关系
      url 是统一资源标识符，代表网络中某个资源的名字，但是通过URl 是无法定位资源符的。
      URL 统一资源定位符，代表网络中某个资源的，同时，通过URL是可以定位到该资源的。
      URL是包括了URl的
      http://localhost:8080/servlet06/index.html 这是 URL
      /servlet06/index.html 这是 URL 。
  2. 请求头
  3. 空白行
   空白行是用来区分："请求头" 和 "请求体"
  4. 请求体
    向服务器发送的具体数据。

HTTP的响应协议：
  1. 状态行
  2. 响应头
  3. 空白行
  4. 响应体


状态行：三部分组成：

Request URL: http://127.0.0.1:8080/servlet06/get?username=Tom&password=123
Request Method: GET
Status Code: 200
Remote Address: 127.0.0.1:8080
Referrer Policy: strict-origin-when-cross-origin

第一部分: 协议版本号:(HTTP/1.1)
第二部分: 状态码: (HTTP协议中规定的响应状态号，不同的响应结果对应不同的号码：)
   > 200 表示请求响应成功，正常结束
   > 404 表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是
   服务器中对应的资源并没有启动成功，总之404错误是前端错误。
   > 405 表示前端发送的请求方式与后端请求的处理方式不一致时发生：
     > 比如：前端是POSt请求，后端的处理方式按照get方式进行处理时，发生405
     > 比如：前端时get请求，后端的处理方式按照post方式进行处理时，发生405
   500表示服务器端的程序出现了异常，一般会认为时服务端的错误导致的。
   总之：以4开始的，一般是浏览器的错误导致的。而以5开始的，一般是服务端的错误导致的。

第三部分: 状态描述信息
      > ok 表示正常成功结果
      > not found 表示资源找不到。
响应头:
   响应的内容类型，
   响应的内容长度，
   响应的时间。
   ...
空白行：用来分隔 “响应头” 和 “响应体”
响应体：
 响应体：就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，
    最终展示出效果。
怎么查看协议的内容：
 使用Chrome浏览器：F12，然后找到netWork 通过这个面板可以查看协议的具体内容。

-----------------------------------------------------------------
怎么向服务器发送 get请求 ，怎么向服务器发送 post 请求，使用form 表单，并且form标签中的method属性值为：
 method="post"
> 到目前为止，只有一种情况可以发送post请求：使用form 表单，并且form 标签中的method属性值为：method="post"
> 其他所有情况一律都是 get 请求:
  > 在浏览器地址栏上直接输入 URL,敲回车，属于 get 请求。
  > 在浏览器上直接点击超链接，属于 get 请求。
  > 使用form 表单提交数据时，form 标签中没有写method属性，默认就是 get
  > 或者使用form 的时候，form 标签中method属性值为 method="get"
  > ......

get 请求和 post 请求有什么区别：
  get 请求发送的时候，数据会挂在URL的后面，并且在URL后面添加一个 "?" ,"?" 后面是数据，这样会导致发送
  的数据回显在浏览器的地址栏上。（get请求在请求行上发送数据）
  > http://localhost:8080/servlet06/getServlet?username=tompossword=123
  > get请求只能发送普通的字符串内容，并且发送的字符串长度有限制，不同的浏览器限制不同，这个没有明确规定。
  > get 请求无法发送大量数据量



  post 请求发送数据的时候，在请求体当中发送，不会回显到浏览器的地址栏上，也就是说post发送的数据，
  在浏览器地址栏上看不到。（post 在请求体 当中发送数据）
  > post 请求可以发送任何类型的数据：包括普通字符串，流媒体等信息：视频，声音，图片...
  > post 请求可以发送大数据量，理论上没有任何长度限制。


  get请求和Post 请求如何选择，什么时候使用 GET 请求，什么时候使用POST请求 ？
  > 不管你是 get 请求还是 post 请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的；
    name=vales&name=value&name=value&name=value
  > name 是什么？
    以 form 表单为例：form表单中input标签的name

  > value 是什么？
   以 form 表单为例： form 表单中的input标签的value值
 get 请求在w3c中是这样说的：get请求比较适合从服务器端获取数据。
 post 请求在w3c中是这样说的：post请求比较适合向服务器传送数据。

 get请求是安全的，get请求是决定安全的，因为get请求只是为了从服务器上获取数据，不涉及到数据的修改。
 post请求是危险的，为什么？因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，
 服务器是很危险的，另外post 是为了提交数据 ，所以一般情况下拦截请求的时候，大部分会选择拦截(监听)post请求。
 注意：get 本身是安全的，你不要用错了，用错了之后，又冤枉人家get不安全，你这样不好（比如：登录使用post）


 get 请求是支持缓存的。
  > 任何一个get请求最终的响应结果都会被浏览器缓存起来，在浏览器缓存当中：
    一个get请求的路径，对应一个资源。
    一个get请求的路径，对应一个资源。
    ......

  > 实际上，只要你发送get请求，浏览器做的第一件事情就是先冲缓存 cache 本地浏览器缓存中找，找不到的时候，才会去
  服务器上获取。这种缓存机制目的是为了提高用户的体验。
  > 有没有这样一个需求：我们不希望get请求走缓存，怎么办？怎么避免走缓存？我希望每一次这个get请求都去服务器
  上找资源，我不想找本地浏览器的缓存中取。
   > 只要每一次get请求的请求路径不同即可。：
   https:localhost:8080/servlet6/fajofj01212
   https:localhost:8080/servlet6/fajofj01880 + 系统毫秒数（时间戳）
  > 怎么解决？ 可以在路径的后面添加一个每时每刻都变化的 "时间戳"，这样，每一次的请求路径都不一样，浏览器
  就不走缓存了。

 而 post 请求是不支持缓存的。 post 请求之后，服务器响应的结果不会被浏览器存储起来，因为这个缓存没有意义。

 如果你这个请求是想获取服务器端的数据，还是想想服务器发送数据，如果你是想从服务器上获取资源，
 建议使用get请求，如果你这个请求是为了向服务器提交数据，建议使用post 请求。

 大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是
 需要传给服务器，服务器将这些数据保存/修改等。

 如果表单有敏感信息，还是建议适用post 请求，因为get请求会回显敏感信息到浏览器地址栏上，（例如：密码信息）。
 做文件上传，一定是 post 请求，要传的数据不是普通文本。
 其他情况都可以使用get请求。




